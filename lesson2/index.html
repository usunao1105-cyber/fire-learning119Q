lesson2/index.html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šè¨€èª ç½å®³æ™‚èª˜å°ã‚¢ãƒŠã‚¦ãƒ³ã‚¹ãƒ„ãƒ¼ãƒ«</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Calm Preparedness (#FAF8F5 Warm Neutral, #333D45 Dark Slate, #4A7C59 Muted Green, #D9A443 Muted Gold) -->
    <!-- Application Structure Plan: å˜ä¸€ãƒšãƒ¼ã‚¸ã®ã‚°ãƒªãƒƒãƒ‰ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã€‚ä¸Šéƒ¨ã«ä¸»è¦æ©Ÿèƒ½ã§ã‚ã‚‹ã€Œå…¨è¨€èªé€£ç¶šå†ç”Ÿã€ãƒœã‚¿ãƒ³ã‚’å¤§ããé…ç½®ã—ã€ãã®ä¸‹ã«å€‹åˆ¥å†ç”Ÿãƒœã‚¿ãƒ³ã‚’ä¸¦ã¹ã‚‹ã“ã¨ã§ã€ç·Šæ€¥æ™‚ã®æ“ä½œå„ªå…ˆåº¦ã‚’æ˜ç¢ºã«ã—ãŸã€‚ãƒ¯ãƒ³ã‚¯ãƒªãƒƒã‚¯ã§æœ€ã‚‚é‡è¦ãªæ©Ÿèƒ½ãŒä½œå‹•ã™ã‚‹UIã¯ã€æŒ‡æ®å®˜ã®è² æ‹…ã‚’è»½æ¸›ã™ã‚‹ã€‚ -->
    <!-- Visualization & Content Choices: 
        - å ±å‘Šæ›¸æƒ…å ±: ã€Œæ­©ã‘ã‚‹äººã¯ã“ã¡ã‚‰ã¸ã€ã®å¤šè¨€èªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ â†’ ç›®çš„: é€£ç¶šéŸ³å£°å†ç”Ÿ â†’ ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ©ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³: å¤§ããªå†ç”Ÿ/åœæ­¢ãƒœã‚¿ãƒ³ã¨ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹è¡¨ç¤ºã‚¨ãƒªã‚¢ã‚’è¿½åŠ  â†’ ã‚¤ãƒ³ã‚¿ãƒ©ã‚¯ã‚·ãƒ§ãƒ³: ã‚¯ãƒªãƒƒã‚¯ã§å…¨è¨€èªã®éŸ³å£°ã‚’5å›ãƒ«ãƒ¼ãƒ—å†ç”Ÿã€å†ã‚¯ãƒªãƒƒã‚¯ã§åœæ­¢ â†’ ç†ç”±: ç¾å ´ã§ä¸€åº¦æ“ä½œã™ã‚Œã°ã€ã‚ã¨ã¯è»Šä¸¡ã‚¹ãƒ”ãƒ¼ã‚«ãƒ¼ã§ã®æ‹¡å£°ã«é›†ä¸­ã§ãã‚‹ã‚ˆã†ã€ãƒãƒ³ã‚ºãƒ•ãƒªãƒ¼ã«è¿‘ã„é‹ç”¨ã‚’å®Ÿç¾ã™ã‚‹ãŸã‚ã€‚å†ç”ŸçŠ¶æ³ã®ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯ã‚‚æä¾›ã—ã€ç¢ºå®Ÿãªæ“ä½œã‚’æ”¯æ´ã™ã‚‹ã€‚ -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #FAF8F5;
            color: #333D45;
        }
        .btn-play.loading, #play-all-btn.loading {
            background-color: #D9A443;
            cursor: wait;
        }
        .btn-play.playing, #play-all-btn.playing {
            background-color: #d32f2f; /* Red for Stop/Playing */
            color: white;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">
    <header class="bg-white shadow-sm sticky top-0 z-10">
        <div class="container mx-auto px-4 py-4 text-center">
            <h1 class="text-2xl md:text-3xl font-bold text-[#333D45]">å¤šè¨€èª ç½å®³æ™‚èª˜å°ã‚¢ãƒŠã‚¦ãƒ³ã‚¹ãƒ„ãƒ¼ãƒ«</h1>
            <p class="text-md text-gray-600 mt-1">ã‚¢ã‚¸ã‚¢ç«¶æŠ€å¤§ä¼š2026 å²¡å´ä¼šå ´ ç½å®³å¯¾å¿œ</p>
        </div>
    </header>

    <main class="flex-grow container mx-auto px-4 py-8">
        <div class="max-w-4xl mx-auto bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 class="text-xl font-bold mb-3 text-center">ä¸€æ–‰ã‚¢ãƒŠã‚¦ãƒ³ã‚¹</h2>
            <p class="text-center text-gray-600 mb-4">ä¸‹ã®ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ã€å…¨ã¦ã®è¨€èªã®ã‚¢ãƒŠã‚¦ãƒ³ã‚¹ãŒ5å›é€£ç¶šã§å†ç”Ÿã•ã‚Œã¾ã™ã€‚å†ç”Ÿä¸­ã«å†åº¦ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨åœæ­¢ã—ã¾ã™ã€‚</p>
            <button id="play-all-btn" class="w-full bg-[#D9A443] text-white font-bold py-4 px-4 rounded-lg hover:bg-[#c8943a] transition-colors flex items-center justify-center text-xl shadow-lg">
                <span class="play-icon">â–¶</span>
                <span class="button-text ml-3">å…¨è¨€èª é€£ç¶šå†ç”Ÿ (5å›)</span>
            </button>
            <div id="play-all-status" class="mt-4 text-center text-gray-700 font-semibold h-6"></div>
        </div>

        <div class="max-w-4xl mx-auto border-t pt-8">
             <h2 class="text-xl font-bold mb-4 text-center">å€‹åˆ¥ã‚¢ãƒŠã‚¦ãƒ³ã‚¹</h2>
             <p class="text-center text-gray-600 mb-6">è¨€èªã‚’é¸æŠã—ã¦å€‹åˆ¥ã«å†ç”Ÿã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚</p>
             <div id="audio-grid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
             </div>
        </div>
    </main>

    <footer class="bg-[#333D45] text-white mt-8">
        <div class="container mx-auto px-4 py-4 text-center text-sm">
            <p>ç·Šæ€¥æ™‚ã®å††æ»‘ãªé¿é›£èª˜å°ã®ãŸã‚ã«</p>
        </div>
    </footer>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const audioGrid = document.getElementById('audio-grid');
        const playAllBtn = document.getElementById('play-all-btn');
        const playAllStatus = document.getElementById('play-all-status');

        let currentlyPlaying = null;
        let isSequencePlaying = false;
        let currentLanguageIndex = 0;
        let currentLoopCount = 1;
        const MAX_LOOPS = 5;
        let audioQueue = [];

        const languages = [
            { lang: 'ja-JP', displayNameJP: 'æ—¥æœ¬èª', displayNameNative: 'æ—¥æœ¬èª', flag: 'ğŸ‡¯ğŸ‡µ', text: 'æ­©ã‘ã‚‹æ–¹ã¯ã€ã“ã¡ã‚‰ã¸æ¥ã¦ãã ã•ã„ã€‚è½ã¡ç€ã„ã¦ç§»å‹•ã—ã¦ãã ã•ã„ã€‚' },
            { lang: 'en-US', displayNameJP: 'è‹±èª', displayNameNative: 'English', flag: 'ğŸ‡ºğŸ‡¸', text: 'If you are able to walk, please come this way. Please move calmly.' },
            { lang: 'zh-CN', displayNameJP: 'ä¸­å›½èª (ç°¡ä½“)', displayNameNative: 'ç®€ä½“ä¸­æ–‡', flag: 'ğŸ‡¨ğŸ‡³', text: 'å¦‚æœæ‚¨å¯ä»¥è¡Œèµ°ï¼Œè¯·åˆ°è¿™è¾¹æ¥ã€‚è¯·å†·é™ç§»åŠ¨ã€‚' },
            { lang: 'ko-KR', displayNameJP: 'éŸ“å›½èª', displayNameNative: 'í•œêµ­ì–´', flag: 'ğŸ‡°ğŸ‡·', text: 'ê±¸ì„ ìˆ˜ ìˆëŠ” ë¶„ì€ ì´ìª½ìœ¼ë¡œ ì˜¤ì„¸ìš”. ì¹¨ì°©í•˜ê²Œ ì´ë™í•´ ì£¼ì„¸ìš”.' },
            { lang: 'hi-IN', displayNameJP: 'ãƒ’ãƒ³ãƒ‡ã‚£ãƒ¼èª', displayNameNative: 'à¤¹à¤¿à¤¨à¥à¤¦à¥€', flag: 'ğŸ‡®ğŸ‡³', text: 'à¤¯à¤¦à¤¿ à¤†à¤ª à¤šà¤² à¤¸à¤•à¤¤à¥‡ à¤¹à¥ˆà¤‚, à¤¤à¥‹ à¤•à¥ƒà¤ªà¤¯à¤¾ à¤‡à¤¸ à¤¤à¤°à¤« à¤†à¤à¤‚à¥¤ à¤•à¥ƒà¤ªà¤¯à¤¾ à¤¶à¤¾à¤‚à¤¤à¤¿ à¤¸à¥‡ à¤†à¤—à¥‡ à¤¬à¤¢à¤¼à¥‡à¤‚à¥¤' },
            { lang: 'id-ID', displayNameJP: 'ã‚¤ãƒ³ãƒ‰ãƒã‚·ã‚¢èª', displayNameNative: 'Bahasa Indonesia', flag: 'ğŸ‡®ğŸ‡©', text: 'Jika Anda bisa berjalan, silakan datang ke sini. Harap bergerak dengan tenang.' },
            { lang: 'vi-VN', displayNameJP: 'ãƒ™ãƒˆãƒŠãƒ èª', displayNameNative: 'Tiáº¿ng Viá»‡t', flag: 'ğŸ‡»ğŸ‡³', text: 'Náº¿u quÃ½ vá»‹ cÃ³ thá»ƒ Ä‘i láº¡i Ä‘Æ°á»£c, xin má»i Ä‘i lá»‘i nÃ y. Vui lÃ²ng di chuyá»ƒn bÃ¬nh tÄ©nh.'},
            { lang: 'th-TH', displayNameJP: 'ã‚¿ã‚¤èª', displayNameNative: 'à¸ à¸²à¸©à¸²à¹„à¸—à¸¢', flag: 'ğŸ‡¹ğŸ‡­', text: 'à¸«à¸²à¸à¸—à¹ˆà¸²à¸™à¸ªà¸²à¸¡à¸²à¸£à¸–à¹€à¸”à¸´à¸™à¹„à¸”à¹‰ à¹‚à¸›à¸£à¸”à¸¡à¸²à¸—à¸²à¸‡à¸™à¸µà¹‰ à¸à¸£à¸¸à¸“à¸²à¹€à¸„à¸¥à¸·à¹ˆà¸­à¸™à¸—à¸µà¹ˆà¸­à¸¢à¹ˆà¸²à¸‡à¹ƒà¸ˆà¹€à¸¢à¹‡à¸™'}
        ];

        languages.forEach(lang => {
            const card = document.createElement('div');
            card.className = 'bg-white p-4 rounded-lg shadow-md flex flex-col justify-between';
            card.innerHTML = `
                <div>
                    <div class="flex items-center mb-3">
                        <span class="text-3xl mr-3">${lang.flag}</span>
                        <div>
                            <h3 class="text-xl font-bold">${lang.displayNameNative}</h3>
                            <p class="text-sm text-gray-500">${lang.displayNameJP}</p>
                        </div>
                    </div>
                </div>
                <button data-text="${lang.text}" class="btn-play w-full mt-4 bg-[#4A7C59] text-white font-bold py-3 px-4 rounded-lg hover:bg-[#3e664b] transition-colors flex items-center justify-center text-xl">
                    <span class="play-icon">â–¶</span>
                    <span class="button-text ml-2">å†ç”Ÿ</span>
                </button>
            `;
            audioGrid.appendChild(card);
        });
        
        // Individual play logic
        audioGrid.addEventListener('click', async (e) => {
            const button = e.target.closest('.btn-play');
            if (!button || button.classList.contains('loading') || button.classList.contains('playing') || isSequencePlaying) return;

            if (currentlyPlaying) {
                currentlyPlaying.pause();
                currentlyPlaying.currentTime = 0;
            }

            const textToSpeak = button.dataset.text;
            setButtonState(button, 'loading');

            try {
                const audioUrl = await generateAndGetAudioUrl(textToSpeak);
                if (audioUrl) playAudio(audioUrl, button);
                else throw new Error('Audio URL not created.');
            } catch (error) {
                console.error('Error generating or playing audio:', error);
                setButtonState(button, 'default');
            }
        });

        // Sequential play logic
        playAllBtn.addEventListener('click', () => {
            if (isSequencePlaying) {
                stopSequentialPlayback();
            } else {
                startSequentialPlayback();
            }
        });

        async function startSequentialPlayback() {
            isSequencePlaying = true;
            setPlayAllButtonState('loading');
            playAllStatus.textContent = 'éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆä¸­... ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚';

            try {
                const promises = languages.map(lang => generateAndGetAudioUrl(lang.text));
                audioQueue = await Promise.all(promises);
                
                currentLanguageIndex = 0;
                currentLoopCount = 1;
                playNextInSequence();

            } catch (error) {
                console.error("Error pre-generating audio:", error);
                playAllStatus.textContent = "éŸ³å£°ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚";
                stopSequentialPlayback();
            }
        }
        
        function playNextInSequence() {
            if (!isSequencePlaying) return;

            if (currentLanguageIndex >= languages.length) {
                currentLoopCount++;
                if (currentLoopCount > MAX_LOOPS) {
                    stopSequentialPlayback();
                    return;
                }
                currentLanguageIndex = 0;
            }

            const lang = languages[currentLanguageIndex];
            const audioUrl = audioQueue[currentLanguageIndex];
            
            playAllStatus.textContent = `å†ç”Ÿä¸­: ${lang.displayNameNative} (ãƒ«ãƒ¼ãƒ—: ${currentLoopCount}/${MAX_LOOPS})`;
            setPlayAllButtonState('playing');

            currentlyPlaying = new Audio(audioUrl);
            currentlyPlaying.play();
            currentlyPlaying.onended = () => {
                currentLanguageIndex++;
                playNextInSequence();
            };
            currentlyPlaying.onerror = () => {
                 console.error(`Error playing audio for ${lang.displayNameNative}`);
                 currentLanguageIndex++;
                 playNextInSequence(); // Skip to the next one on error
            }
        }

        function stopSequentialPlayback() {
            isSequencePlaying = false;
            if (currentlyPlaying) {
                currentlyPlaying.pause();
                currentlyPlaying = null;
            }
            audioQueue.forEach(url => URL.revokeObjectURL(url));
            audioQueue = [];
            playAllStatus.textContent = '';
            setPlayAllButtonState('default');
        }

        function setPlayAllButtonState(state) {
            const icon = playAllBtn.querySelector('.play-icon');
            const text = playAllBtn.querySelector('.button-text');
            playAllBtn.classList.remove('loading', 'playing');

            if (state === 'loading') {
                playAllBtn.classList.add('loading');
                text.textContent = 'ç”Ÿæˆä¸­...';
            } else if (state === 'playing') {
                playAllBtn.classList.add('playing');
                icon.textContent = 'â– ';
                text.textContent = 'åœæ­¢';
            } else { // default
                icon.textContent = 'â–¶';
                text.textContent = 'å…¨è¨€èª é€£ç¶šå†ç”Ÿ (5å›)';
            }
        }

        function setButtonState(button, state) {
            const playIcon = button.querySelector('.play-icon');
            button.classList.remove('loading', 'playing');

            if (state === 'loading') {
                button.classList.add('loading');
            } else if (state === 'playing') {
                button.classList.add('playing');
                playIcon.textContent = 'â– ';
            } else { // default
                playIcon.textContent = 'â–¶';
            }
        }

        function playAudio(url, button) {
             currentlyPlaying = new Audio(url);
             setButtonState(button, 'playing');
             currentlyPlaying.play();
             currentlyPlaying.onended = () => {
                setButtonState(button, 'default');
                URL.revokeObjectURL(url);
                currentlyPlaying = null;
             };
             currentlyPlaying.onerror = () => {
                setButtonState(button, 'default');
                URL.revokeObjectURL(url);
             }
        }
        
        async function generateAndGetAudioUrl(text) {
             const apiKey = "";
             const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
             const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: { responseModalities: ["AUDIO"] },
                model: "gemini-2.5-flash-preview-tts"
             };
             const response = await fetch(apiUrl, {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify(payload)
             });
             if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
             const result = await response.json();
             const audioData = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
             const mimeType = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.mimeType;

             if (audioData && mimeType && mimeType.startsWith("audio/")) {
                const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, 1, sampleRate);
                return URL.createObjectURL(wavBlob);
             }
             return null;
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, numChannels, sampleRate) {
            const buffer = new ArrayBuffer(44 + pcmData.length * 2);
            const view = new DataView(buffer);
            const writeString = (view, offset, string) => {
                for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
            };
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.length * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * 2, true);
            view.setUint16(32, numChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.length * 2, true);
            for (let i = 0; i < pcmData.length; i++) view.setInt16(44 + i * 2, pcmData[i], true);
            return new Blob([view], { type: 'audio/wav' });
        }
    });
    </script>
</body>
</html>

