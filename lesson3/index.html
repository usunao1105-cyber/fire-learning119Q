lesson3/index.html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>多言語 医療トリアージ案内ツール</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Calm Preparedness (#FAF8F5 Warm Neutral, #333D45 Dark Slate, #4A7C59 Muted Green, #D9A443 Muted Gold) -->
    <!-- Application Structure Plan: A single-page, single-purpose application. The design prioritizes immediate action. A large primary button for sequential, looped playback of all languages is placed at the top for the most common use case (continuous announcement). Below, individual language buttons allow for specific, targeted communication if needed. This structure minimizes clicks and cognitive load in a high-stress environment. -->
    <!-- Visualization & Content Choices: 
        - Report Info: Announce the purpose of the triage tent. -> Goal: Continuous, multi-language audio announcement. -> Presentation: A large "Play All" button and individual language cards. -> Interaction: Click to start a 5-time loop of all languages; click again to stop. Individual buttons for single playback. -> Justification: Designed for a stationary announcement scenario. The fire commander can press the button once and let the announcement run, freeing them to manage other tasks. The message is focused and consistent. Audio is generated via Gemini TTS API for clarity and accessibility. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #FAF8F5;
            color: #333D45;
        }
        .btn-play.loading, #play-all-btn.loading {
            background-color: #D9A443;
            cursor: wait;
        }
        .btn-play.playing, #play-all-btn.playing {
            background-color: #d32f2f; /* Red for Stop/Playing */
            color: white;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">
    <header class="bg-white shadow-sm sticky top-0 z-10">
        <div class="container mx-auto px-4 py-4 text-center">
            <h1 class="text-2xl md:text-3xl font-bold text-[#333D45]">多言語 医療トリアージ案内ツール</h1>
            <p class="text-md text-gray-600 mt-1">救護テント前での案内用</p>
        </div>
    </header>

    <main class="flex-grow container mx-auto px-4 py-8">
        <div class="max-w-4xl mx-auto bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 class="text-xl font-bold mb-3 text-center">テント前 継続アナウンス</h2>
            <p class="text-center text-gray-600 mb-4">下のボタンを押すと、テント前での案内が全言語で5回連続再生されます。再生中に再度ボタンを押すと停止します。</p>
            <button id="play-all-btn" class="w-full bg-[#4A7C59] text-white font-bold py-4 px-4 rounded-lg hover:bg-[#3e664b] transition-colors flex items-center justify-center text-xl shadow-lg">
                <span class="play-icon">▶</span>
                <span class="button-text ml-3">全言語 連続再生 (5回)</span>
            </button>
            <div id="play-all-status" class="mt-4 text-center text-gray-700 font-semibold h-6"></div>
        </div>

        <div class="max-w-4xl mx-auto border-t pt-8">
             <h2 class="text-xl font-bold mb-4 text-center">個別アナウンス</h2>
             <p class="text-center text-gray-600 mb-6">言語を選択して個別に再生することも可能です。</p>
             <div id="audio-grid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
             </div>
        </div>
    </main>

    <footer class="bg-[#333D45] text-white mt-8">
        <div class="container mx-auto px-4 py-4 text-center text-sm">
            <p>重症者の救護活動へのご協力をお願いします</p>
        </div>
    </footer>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const audioGrid = document.getElementById('audio-grid');
        const playAllBtn = document.getElementById('play-all-btn');
        const playAllStatus = document.getElementById('play-all-status');

        let currentlyPlaying = null;
        let isSequencePlaying = false;
        let currentLanguageIndex = 0;
        let currentLoopCount = 1;
        const MAX_LOOPS = 5;
        let audioQueue = [];

        const languages = [
            { lang: 'ja-JP', displayNameJP: '日本語', displayNameNative: '日本語', flag: '🇯🇵', text: '現在、このテント内で、怪我の重症度を判断し、治療の優先順位を決めるトリアージを行っています。重症の方から医療機関へ搬送しますので、静粛にご協力をお願いいたします。' },
            { lang: 'en-US', displayNameJP: '英語', displayNameNative: 'English', flag: '🇺🇸', text: 'We are currently conducting triage inside this tent to determine the severity of injuries and prioritize treatment. Patients will be transported to medical facilities in order of severity. We ask for your quiet cooperation.' },
            { lang: 'zh-CN', displayNameJP: '中国語 (簡体)', displayNameNative: '简体中文', flag: '🇨🇳', text: '我们正在帐篷内进行伤员检伤分类，以确定治疗的优先顺序。伤员将按重症程度送往相应的医疗机构。请您安静配合。' },
            { lang: 'ko-KR', displayNameJP: '韓国語', displayNameNative: '한국어', flag: '🇰🇷', text: '현재 이 텐트 안에서 치료 우선순위를 결정하기 위한 부상자 분류를 실시하고 있습니다. 중상자부터 순서대로 적절한 의료기관으로 이송하겠습니다. 조용히 협조해 주시기 바랍니다.' },
            { lang: 'hi-IN', displayNameJP: 'ヒンディー語', displayNameNative: 'हिन्दी', flag: '🇮🇳', text: 'हम इस टेंट के अंदर चोटों की गंभीरता का पता लगाने और उपचार को प्राथमिकता देने के लिए मरीज़ों का वर्गीकरण कर रहे हैं। मरीज़ों को गंभीरता के क्रम में चिकित्सा सुविधाओं में ले जाया जाएगा। हम आपके शांत सहयोग का अनुरोध करते हैं।' },
            { lang: 'id-ID', displayNameJP: 'インドネシア語', displayNameNative: 'Bahasa Indonesia', flag: '🇮🇩', text: 'Saat ini kami sedang melakukan triase di dalam tenda ini untuk menentukan tingkat keparahan cedera dan memprioritaskan perawatan. Pasien akan diangkut ke fasilitas medis sesuai urutan tingkat keparahan. Kami mohon kerja sama Anda dengan tenang.' },
            { lang: 'vi-VN', displayNameJP: 'ベトナム語', displayNameNative: 'Tiếng Việt', flag: '🇻🇳', text: 'Chúng tôi hiện đang tiến hành phân loại cứu thương bên trong lều này để xác định mức độ nghiêm trọng của vết thương và ưu tiên điều trị. Bệnh nhân sẽ được vận chuyển đến các cơ sở y tế theo thứ tự nghiêm trọng. Chúng tôi yêu cầu sự hợp tác trong im lặng của quý vị.' },
            { lang: 'th-TH', displayNameJP: 'タイ語', displayNameNative: 'ภาษาไทย', flag: '🇹🇭', text: 'ขณะนี้เรากำลังทำการคัดแยกผู้บาดเจ็บภายในเต็นท์นี้เพื่อประเมินความรุนแรงของอาการบาดเจ็บและจัดลำดับความสำคัญในการรักษา ผู้ป่วยจะถูกส่งไปยังสถานพยาบาลตามลำดับความรุนแรง ขอความร่วมมือทุกท่านอยู่ในความสงบ' }
        ];

        languages.forEach(lang => {
            const card = document.createElement('div');
            card.className = 'bg-white p-4 rounded-lg shadow-md flex flex-col justify-between';
            card.innerHTML = `
                <div>
                    <div class="flex items-center mb-3">
                        <span class="text-3xl mr-3">${lang.flag}</span>
                        <div>
                            <h3 class="text-xl font-bold">${lang.displayNameNative}</h3>
                            <p class="text-sm text-gray-500">${lang.displayNameJP}</p>
                        </div>
                    </div>
                     <p class="text-gray-700 text-sm p-2 bg-gray-50 rounded italic">"${lang.text}"</p>
                </div>
                <button data-text="${lang.text}" class="btn-play w-full mt-4 bg-[#4A7C59] text-white font-bold py-3 px-4 rounded-lg hover:bg-[#3e664b] transition-colors flex items-center justify-center text-xl">
                    <span class="play-icon">▶</span>
                    <span class="button-text ml-2">再生</span>
                </button>
            `;
            audioGrid.appendChild(card);
        });
        
        audioGrid.addEventListener('click', async (e) => {
            const button = e.target.closest('.btn-play');
            if (!button || button.classList.contains('loading') || button.classList.contains('playing') || isSequencePlaying) return;

            if (currentlyPlaying) {
                currentlyPlaying.pause();
                currentlyPlaying.currentTime = 0;
            }

            const textToSpeak = button.dataset.text;
            setButtonState(button, 'loading');

            try {
                const audioUrl = await generateAndGetAudioUrl(textToSpeak);
                if (audioUrl) playAudio(audioUrl, button);
                else throw new Error('Audio URL not created.');
            } catch (error) {
                console.error('Error generating or playing audio:', error);
                setButtonState(button, 'default');
            }
        });

        playAllBtn.addEventListener('click', () => {
            if (isSequencePlaying) {
                stopSequentialPlayback();
            } else {
                startSequentialPlayback();
            }
        });

        async function startSequentialPlayback() {
            isSequencePlaying = true;
            setPlayAllButtonState('loading');
            playAllStatus.textContent = '音声データを生成中... しばらくお待ちください。';

            try {
                const promises = languages.map(lang => generateAndGetAudioUrl(lang.text));
                audioQueue = await Promise.all(promises);
                
                currentLanguageIndex = 0;
                currentLoopCount = 1;
                playNextInSequence();

            } catch (error) {
                console.error("Error pre-generating audio:", error);
                playAllStatus.textContent = "音声の生成に失敗しました。";
                stopSequentialPlayback();
            }
        }
        
        function playNextInSequence() {
            if (!isSequencePlaying) return;

            if (currentLanguageIndex >= languages.length) {
                currentLoopCount++;
                if (currentLoopCount > MAX_LOOPS) {
                    stopSequentialPlayback();
                    return;
                }
                currentLanguageIndex = 0;
            }

            const lang = languages[currentLanguageIndex];
            const audioUrl = audioQueue[currentLanguageIndex];
            
            playAllStatus.textContent = `再生中: ${lang.displayNameNative} (ループ: ${currentLoopCount}/${MAX_LOOPS})`;
            setPlayAllButtonState('playing');

            currentlyPlaying = new Audio(audioUrl);
            currentlyPlaying.play();
            currentlyPlaying.onended = () => {
                currentLanguageIndex++;
                playNextInSequence();
            };
            currentlyPlaying.onerror = () => {
                 console.error(`Error playing audio for ${lang.displayNameNative}`);
                 currentLanguageIndex++;
                 playNextInSequence();
            }
        }

        function stopSequentialPlayback() {
            isSequencePlaying = false;
            if (currentlyPlaying) {
                currentlyPlaying.pause();
                currentlyPlaying = null;
            }
            audioQueue.forEach(url => URL.revokeObjectURL(url));
            audioQueue = [];
            playAllStatus.textContent = '';
            setPlayAllButtonState('default');
        }

        function setPlayAllButtonState(state) {
            const icon = playAllBtn.querySelector('.play-icon');
            const text = playAllBtn.querySelector('.button-text');
            playAllBtn.classList.remove('loading', 'playing');

            if (state === 'loading') {
                playAllBtn.classList.add('loading');
                text.textContent = '生成中...';
            } else if (state === 'playing') {
                playAllBtn.classList.add('playing');
                icon.textContent = '■';
                text.textContent = '停止';
            } else {
                icon.textContent = '▶';
                text.textContent = '全言語 連続再生 (5回)';
            }
        }

        function setButtonState(button, state) {
            const playIcon = button.querySelector('.play-icon');
            button.classList.remove('loading', 'playing');

            if (state === 'loading') button.classList.add('loading');
            else if (state === 'playing') {
                button.classList.add('playing');
                playIcon.textContent = '■';
            } else {
                playIcon.textContent = '▶';
            }
        }

        function playAudio(url, button) {
             currentlyPlaying = new Audio(url);
             setButtonState(button, 'playing');
             currentlyPlaying.play();
             currentlyPlaying.onended = () => {
                setButtonState(button, 'default');
                URL.revokeObjectURL(url);
                currentlyPlaying = null;
             };
             currentlyPlaying.onerror = () => {
                setButtonState(button, 'default');
                URL.revokeObjectURL(url);
             }
        }
        
        async function generateAndGetAudioUrl(text) {
             const apiKey = "AIzaSyAM1ZZibznTJZ9nSzWTrdw7zKyyBX8UmVM"; // Provided API Key
             const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
             const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: { responseModalities: ["AUDIO"] },
                model: "gemini-2.5-flash-preview-tts"
             };
             const response = await fetch(apiUrl, {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify(payload)
             });
             if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
             const result = await response.json();
             const audioData = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
             const mimeType = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.mimeType;

             if (audioData && mimeType && mimeType.startsWith("audio/")) {
                const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, 1, sampleRate);
                return URL.createObjectURL(wavBlob);
             }
             return null;
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, numChannels, sampleRate) {
            const buffer = new ArrayBuffer(44 + pcmData.length * 2);
            const view = new DataView(buffer);
            const writeString = (view, offset, string) => {
                for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
            };
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.length * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * 2, true);
            view.setUint16(32, numChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.length * 2, true);
            for (let i = 0; i < pcmData.length; i++) view.setInt16(44 + i * 2, pcmData[i], true);
            return new Blob([view], { type: 'audio/wav' });
        }
    });
    </script>
</body>
</html>


