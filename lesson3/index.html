lesson3/index.html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å¤šè¨€èª åŒ»ç™‚ãƒˆãƒªã‚¢ãƒ¼ã‚¸æ¡ˆå†…ãƒ„ãƒ¼ãƒ«</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;700&display=swap" rel="stylesheet">
    <!-- Chosen Palette: Calm Preparedness (#FAF8F5 Warm Neutral, #333D45 Dark Slate, #4A7C59 Muted Green, #D9A443 Muted Gold) -->
    <!-- Application Structure Plan: A single-page, single-purpose application. The design prioritizes immediate action. A large primary button for sequential, looped playback of all languages is placed at the top for the most common use case (continuous announcement). Below, individual language buttons allow for specific, targeted communication if needed. This structure minimizes clicks and cognitive load in a high-stress environment. -->
    <!-- Visualization & Content Choices: 
        - Report Info: Announce the purpose of the triage tent. -> Goal: Continuous, multi-language audio announcement. -> Presentation: A large "Play All" button and individual language cards. -> Interaction: Click to start a 5-time loop of all languages; click again to stop. Individual buttons for single playback. -> Justification: Designed for a stationary announcement scenario. The fire commander can press the button once and let the announcement run, freeing them to manage other tasks. The message is focused and consistent. Audio is generated via Gemini TTS API for clarity and accessibility. -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
        body {
            font-family: 'Noto Sans JP', sans-serif;
            background-color: #FAF8F5;
            color: #333D45;
        }
        .btn-play.loading, #play-all-btn.loading {
            background-color: #D9A443;
            cursor: wait;
        }
        .btn-play.playing, #play-all-btn.playing {
            background-color: #d32f2f; /* Red for Stop/Playing */
            color: white;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col">
    <header class="bg-white shadow-sm sticky top-0 z-10">
        <div class="container mx-auto px-4 py-4 text-center">
            <h1 class="text-2xl md:text-3xl font-bold text-[#333D45]">å¤šè¨€èª åŒ»ç™‚ãƒˆãƒªã‚¢ãƒ¼ã‚¸æ¡ˆå†…ãƒ„ãƒ¼ãƒ«</h1>
            <p class="text-md text-gray-600 mt-1">æ•‘è­·ãƒ†ãƒ³ãƒˆå‰ã§ã®æ¡ˆå†…ç”¨</p>
        </div>
    </header>

    <main class="flex-grow container mx-auto px-4 py-8">
        <div class="max-w-4xl mx-auto bg-white p-6 rounded-lg shadow-md mb-8">
            <h2 class="text-xl font-bold mb-3 text-center">ãƒ†ãƒ³ãƒˆå‰ ç¶™ç¶šã‚¢ãƒŠã‚¦ãƒ³ã‚¹</h2>
            <p class="text-center text-gray-600 mb-4">ä¸‹ã®ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨ã€ãƒ†ãƒ³ãƒˆå‰ã§ã®æ¡ˆå†…ãŒå…¨è¨€èªã§5å›é€£ç¶šå†ç”Ÿã•ã‚Œã¾ã™ã€‚å†ç”Ÿä¸­ã«å†åº¦ãƒœã‚¿ãƒ³ã‚’æŠ¼ã™ã¨åœæ­¢ã—ã¾ã™ã€‚</p>
            <button id="play-all-btn" class="w-full bg-[#4A7C59] text-white font-bold py-4 px-4 rounded-lg hover:bg-[#3e664b] transition-colors flex items-center justify-center text-xl shadow-lg">
                <span class="play-icon">â–¶</span>
                <span class="button-text ml-3">å…¨è¨€èª é€£ç¶šå†ç”Ÿ (5å›)</span>
            </button>
            <div id="play-all-status" class="mt-4 text-center text-gray-700 font-semibold h-6"></div>
        </div>

        <div class="max-w-4xl mx-auto border-t pt-8">
             <h2 class="text-xl font-bold mb-4 text-center">å€‹åˆ¥ã‚¢ãƒŠã‚¦ãƒ³ã‚¹</h2>
             <p class="text-center text-gray-600 mb-6">è¨€èªã‚’é¸æŠã—ã¦å€‹åˆ¥ã«å†ç”Ÿã™ã‚‹ã“ã¨ã‚‚å¯èƒ½ã§ã™ã€‚</p>
             <div id="audio-grid" class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6">
             </div>
        </div>
    </main>

    <footer class="bg-[#333D45] text-white mt-8">
        <div class="container mx-auto px-4 py-4 text-center text-sm">
            <p>é‡ç—‡è€…ã®æ•‘è­·æ´»å‹•ã¸ã®ã”å”åŠ›ã‚’ãŠé¡˜ã„ã—ã¾ã™</p>
        </div>
    </footer>

    <script>
    document.addEventListener('DOMContentLoaded', () => {
        const audioGrid = document.getElementById('audio-grid');
        const playAllBtn = document.getElementById('play-all-btn');
        const playAllStatus = document.getElementById('play-all-status');

        let currentlyPlaying = null;
        let isSequencePlaying = false;
        let currentLanguageIndex = 0;
        let currentLoopCount = 1;
        const MAX_LOOPS = 5;
        let audioQueue = [];

        const languages = [
            { lang: 'ja-JP', displayNameJP: 'æ—¥æœ¬èª', displayNameNative: 'æ—¥æœ¬èª', flag: 'ğŸ‡¯ğŸ‡µ', text: 'ç¾åœ¨ã€ã“ã®ãƒ†ãƒ³ãƒˆå†…ã§ã€æ€ªæˆ‘ã®é‡ç—‡åº¦ã‚’åˆ¤æ–­ã—ã€æ²»ç™‚ã®å„ªå…ˆé †ä½ã‚’æ±ºã‚ã‚‹ãƒˆãƒªã‚¢ãƒ¼ã‚¸ã‚’è¡Œã£ã¦ã„ã¾ã™ã€‚é‡ç—‡ã®æ–¹ã‹ã‚‰åŒ»ç™‚æ©Ÿé–¢ã¸æ¬é€ã—ã¾ã™ã®ã§ã€é™ç²›ã«ã”å”åŠ›ã‚’ãŠé¡˜ã„ã„ãŸã—ã¾ã™ã€‚' },
            { lang: 'en-US', displayNameJP: 'è‹±èª', displayNameNative: 'English', flag: 'ğŸ‡ºğŸ‡¸', text: 'We are currently conducting triage inside this tent to determine the severity of injuries and prioritize treatment. Patients will be transported to medical facilities in order of severity. We ask for your quiet cooperation.' },
            { lang: 'zh-CN', displayNameJP: 'ä¸­å›½èª (ç°¡ä½“)', displayNameNative: 'ç®€ä½“ä¸­æ–‡', flag: 'ğŸ‡¨ğŸ‡³', text: 'æˆ‘ä»¬æ­£åœ¨å¸ç¯·å†…è¿›è¡Œä¼¤å‘˜æ£€ä¼¤åˆ†ç±»ï¼Œä»¥ç¡®å®šæ²»ç–—çš„ä¼˜å…ˆé¡ºåºã€‚ä¼¤å‘˜å°†æŒ‰é‡ç—‡ç¨‹åº¦é€å¾€ç›¸åº”çš„åŒ»ç–—æœºæ„ã€‚è¯·æ‚¨å®‰é™é…åˆã€‚' },
            { lang: 'ko-KR', displayNameJP: 'éŸ“å›½èª', displayNameNative: 'í•œêµ­ì–´', flag: 'ğŸ‡°ğŸ‡·', text: 'í˜„ì¬ ì´ í…íŠ¸ ì•ˆì—ì„œ ì¹˜ë£Œ ìš°ì„ ìˆœìœ„ë¥¼ ê²°ì •í•˜ê¸° ìœ„í•œ ë¶€ìƒì ë¶„ë¥˜ë¥¼ ì‹¤ì‹œí•˜ê³  ìˆìŠµë‹ˆë‹¤. ì¤‘ìƒìë¶€í„° ìˆœì„œëŒ€ë¡œ ì ì ˆí•œ ì˜ë£Œê¸°ê´€ìœ¼ë¡œ ì´ì†¡í•˜ê² ìŠµë‹ˆë‹¤. ì¡°ìš©íˆ í˜‘ì¡°í•´ ì£¼ì‹œê¸° ë°”ëë‹ˆë‹¤.' },
            { lang: 'hi-IN', displayNameJP: 'ãƒ’ãƒ³ãƒ‡ã‚£ãƒ¼èª', displayNameNative: 'à¤¹à¤¿à¤¨à¥à¤¦à¥€', flag: 'ğŸ‡®ğŸ‡³', text: 'à¤¹à¤® à¤‡à¤¸ à¤Ÿà¥‡à¤‚à¤Ÿ à¤•à¥‡ à¤…à¤‚à¤¦à¤° à¤šà¥‹à¤Ÿà¥‹à¤‚ à¤•à¥€ à¤—à¤‚à¤­à¥€à¤°à¤¤à¤¾ à¤•à¤¾ à¤ªà¤¤à¤¾ à¤²à¤—à¤¾à¤¨à¥‡ à¤”à¤° à¤‰à¤ªà¤šà¤¾à¤° à¤•à¥‹ à¤ªà¥à¤°à¤¾à¤¥à¤®à¤¿à¤•à¤¤à¤¾ à¤¦à¥‡à¤¨à¥‡ à¤•à¥‡ à¤²à¤¿à¤ à¤®à¤°à¥€à¤œà¤¼à¥‹à¤‚ à¤•à¤¾ à¤µà¤°à¥à¤—à¥€à¤•à¤°à¤£ à¤•à¤° à¤°à¤¹à¥‡ à¤¹à¥ˆà¤‚à¥¤ à¤®à¤°à¥€à¤œà¤¼à¥‹à¤‚ à¤•à¥‹ à¤—à¤‚à¤­à¥€à¤°à¤¤à¤¾ à¤•à¥‡ à¤•à¥à¤°à¤® à¤®à¥‡à¤‚ à¤šà¤¿à¤•à¤¿à¤¤à¥à¤¸à¤¾ à¤¸à¥à¤µà¤¿à¤§à¤¾à¤“à¤‚ à¤®à¥‡à¤‚ à¤²à¥‡ à¤œà¤¾à¤¯à¤¾ à¤œà¤¾à¤à¤—à¤¾à¥¤ à¤¹à¤® à¤†à¤ªà¤•à¥‡ à¤¶à¤¾à¤‚à¤¤ à¤¸à¤¹à¤¯à¥‹à¤— à¤•à¤¾ à¤…à¤¨à¥à¤°à¥‹à¤§ à¤•à¤°à¤¤à¥‡ à¤¹à¥ˆà¤‚à¥¤' },
            { lang: 'id-ID', displayNameJP: 'ã‚¤ãƒ³ãƒ‰ãƒã‚·ã‚¢èª', displayNameNative: 'Bahasa Indonesia', flag: 'ğŸ‡®ğŸ‡©', text: 'Saat ini kami sedang melakukan triase di dalam tenda ini untuk menentukan tingkat keparahan cedera dan memprioritaskan perawatan. Pasien akan diangkut ke fasilitas medis sesuai urutan tingkat keparahan. Kami mohon kerja sama Anda dengan tenang.' },
            { lang: 'vi-VN', displayNameJP: 'ãƒ™ãƒˆãƒŠãƒ èª', displayNameNative: 'Tiáº¿ng Viá»‡t', flag: 'ğŸ‡»ğŸ‡³', text: 'ChÃºng tÃ´i hiá»‡n Ä‘ang tiáº¿n hÃ nh phÃ¢n loáº¡i cá»©u thÆ°Æ¡ng bÃªn trong lá»u nÃ y Ä‘á»ƒ xÃ¡c Ä‘á»‹nh má»©c Ä‘á»™ nghiÃªm trá»ng cá»§a váº¿t thÆ°Æ¡ng vÃ  Æ°u tiÃªn Ä‘iá»u trá»‹. Bá»‡nh nhÃ¢n sáº½ Ä‘Æ°á»£c váº­n chuyá»ƒn Ä‘áº¿n cÃ¡c cÆ¡ sá»Ÿ y táº¿ theo thá»© tá»± nghiÃªm trá»ng. ChÃºng tÃ´i yÃªu cáº§u sá»± há»£p tÃ¡c trong im láº·ng cá»§a quÃ½ vá»‹.' },
            { lang: 'th-TH', displayNameJP: 'ã‚¿ã‚¤èª', displayNameNative: 'à¸ à¸²à¸©à¸²à¹„à¸—à¸¢', flag: 'ğŸ‡¹ğŸ‡­', text: 'à¸‚à¸“à¸°à¸™à¸µà¹‰à¹€à¸£à¸²à¸à¸³à¸¥à¸±à¸‡à¸—à¸³à¸à¸²à¸£à¸„à¸±à¸”à¹à¸¢à¸à¸œà¸¹à¹‰à¸šà¸²à¸”à¹€à¸ˆà¹‡à¸šà¸ à¸²à¸¢à¹ƒà¸™à¹€à¸•à¹‡à¸™à¸—à¹Œà¸™à¸µà¹‰à¹€à¸à¸·à¹ˆà¸­à¸›à¸£à¸°à¹€à¸¡à¸´à¸™à¸„à¸§à¸²à¸¡à¸£à¸¸à¸™à¹à¸£à¸‡à¸‚à¸­à¸‡à¸­à¸²à¸à¸²à¸£à¸šà¸²à¸”à¹€à¸ˆà¹‡à¸šà¹à¸¥à¸°à¸ˆà¸±à¸”à¸¥à¸³à¸”à¸±à¸šà¸„à¸§à¸²à¸¡à¸ªà¸³à¸„à¸±à¸à¹ƒà¸™à¸à¸²à¸£à¸£à¸±à¸à¸©à¸² à¸œà¸¹à¹‰à¸›à¹ˆà¸§à¸¢à¸ˆà¸°à¸–à¸¹à¸à¸ªà¹ˆà¸‡à¹„à¸›à¸¢à¸±à¸‡à¸ªà¸–à¸²à¸™à¸à¸¢à¸²à¸šà¸²à¸¥à¸•à¸²à¸¡à¸¥à¸³à¸”à¸±à¸šà¸„à¸§à¸²à¸¡à¸£à¸¸à¸™à¹à¸£à¸‡ à¸‚à¸­à¸„à¸§à¸²à¸¡à¸£à¹ˆà¸§à¸¡à¸¡à¸·à¸­à¸—à¸¸à¸à¸—à¹ˆà¸²à¸™à¸­à¸¢à¸¹à¹ˆà¹ƒà¸™à¸„à¸§à¸²à¸¡à¸ªà¸‡à¸š' }
        ];

        languages.forEach(lang => {
            const card = document.createElement('div');
            card.className = 'bg-white p-4 rounded-lg shadow-md flex flex-col justify-between';
            card.innerHTML = `
                <div>
                    <div class="flex items-center mb-3">
                        <span class="text-3xl mr-3">${lang.flag}</span>
                        <div>
                            <h3 class="text-xl font-bold">${lang.displayNameNative}</h3>
                            <p class="text-sm text-gray-500">${lang.displayNameJP}</p>
                        </div>
                    </div>
                     <p class="text-gray-700 text-sm p-2 bg-gray-50 rounded italic">"${lang.text}"</p>
                </div>
                <button data-text="${lang.text}" class="btn-play w-full mt-4 bg-[#4A7C59] text-white font-bold py-3 px-4 rounded-lg hover:bg-[#3e664b] transition-colors flex items-center justify-center text-xl">
                    <span class="play-icon">â–¶</span>
                    <span class="button-text ml-2">å†ç”Ÿ</span>
                </button>
            `;
            audioGrid.appendChild(card);
        });
        
        audioGrid.addEventListener('click', async (e) => {
            const button = e.target.closest('.btn-play');
            if (!button || button.classList.contains('loading') || button.classList.contains('playing') || isSequencePlaying) return;

            if (currentlyPlaying) {
                currentlyPlaying.pause();
                currentlyPlaying.currentTime = 0;
            }

            const textToSpeak = button.dataset.text;
            setButtonState(button, 'loading');

            try {
                const audioUrl = await generateAndGetAudioUrl(textToSpeak);
                if (audioUrl) playAudio(audioUrl, button);
                else throw new Error('Audio URL not created.');
            } catch (error) {
                console.error('Error generating or playing audio:', error);
                setButtonState(button, 'default');
            }
        });

        playAllBtn.addEventListener('click', () => {
            if (isSequencePlaying) {
                stopSequentialPlayback();
            } else {
                startSequentialPlayback();
            }
        });

        async function startSequentialPlayback() {
            isSequencePlaying = true;
            setPlayAllButtonState('loading');
            playAllStatus.textContent = 'éŸ³å£°ãƒ‡ãƒ¼ã‚¿ã‚’ç”Ÿæˆä¸­... ã—ã°ã‚‰ããŠå¾…ã¡ãã ã•ã„ã€‚';

            try {
                const promises = languages.map(lang => generateAndGetAudioUrl(lang.text));
                audioQueue = await Promise.all(promises);
                
                currentLanguageIndex = 0;
                currentLoopCount = 1;
                playNextInSequence();

            } catch (error) {
                console.error("Error pre-generating audio:", error);
                playAllStatus.textContent = "éŸ³å£°ã®ç”Ÿæˆã«å¤±æ•—ã—ã¾ã—ãŸã€‚";
                stopSequentialPlayback();
            }
        }
        
        function playNextInSequence() {
            if (!isSequencePlaying) return;

            if (currentLanguageIndex >= languages.length) {
                currentLoopCount++;
                if (currentLoopCount > MAX_LOOPS) {
                    stopSequentialPlayback();
                    return;
                }
                currentLanguageIndex = 0;
            }

            const lang = languages[currentLanguageIndex];
            const audioUrl = audioQueue[currentLanguageIndex];
            
            playAllStatus.textContent = `å†ç”Ÿä¸­: ${lang.displayNameNative} (ãƒ«ãƒ¼ãƒ—: ${currentLoopCount}/${MAX_LOOPS})`;
            setPlayAllButtonState('playing');

            currentlyPlaying = new Audio(audioUrl);
            currentlyPlaying.play();
            currentlyPlaying.onended = () => {
                currentLanguageIndex++;
                playNextInSequence();
            };
            currentlyPlaying.onerror = () => {
                 console.error(`Error playing audio for ${lang.displayNameNative}`);
                 currentLanguageIndex++;
                 playNextInSequence();
            }
        }

        function stopSequentialPlayback() {
            isSequencePlaying = false;
            if (currentlyPlaying) {
                currentlyPlaying.pause();
                currentlyPlaying = null;
            }
            audioQueue.forEach(url => URL.revokeObjectURL(url));
            audioQueue = [];
            playAllStatus.textContent = '';
            setPlayAllButtonState('default');
        }

        function setPlayAllButtonState(state) {
            const icon = playAllBtn.querySelector('.play-icon');
            const text = playAllBtn.querySelector('.button-text');
            playAllBtn.classList.remove('loading', 'playing');

            if (state === 'loading') {
                playAllBtn.classList.add('loading');
                text.textContent = 'ç”Ÿæˆä¸­...';
            } else if (state === 'playing') {
                playAllBtn.classList.add('playing');
                icon.textContent = 'â– ';
                text.textContent = 'åœæ­¢';
            } else {
                icon.textContent = 'â–¶';
                text.textContent = 'å…¨è¨€èª é€£ç¶šå†ç”Ÿ (5å›)';
            }
        }

        function setButtonState(button, state) {
            const playIcon = button.querySelector('.play-icon');
            button.classList.remove('loading', 'playing');

            if (state === 'loading') button.classList.add('loading');
            else if (state === 'playing') {
                button.classList.add('playing');
                playIcon.textContent = 'â– ';
            } else {
                playIcon.textContent = 'â–¶';
            }
        }

        function playAudio(url, button) {
             currentlyPlaying = new Audio(url);
             setButtonState(button, 'playing');
             currentlyPlaying.play();
             currentlyPlaying.onended = () => {
                setButtonState(button, 'default');
                URL.revokeObjectURL(url);
                currentlyPlaying = null;
             };
             currentlyPlaying.onerror = () => {
                setButtonState(button, 'default');
                URL.revokeObjectURL(url);
             }
        }
        
        async function generateAndGetAudioUrl(text) {
             const apiKey = "AIzaSyAM1ZZibznTJZ9nSzWTrdw7zKyyBX8UmVM"; // Provided API Key
             const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-tts:generateContent?key=${apiKey}`;
             const payload = {
                contents: [{ parts: [{ text: text }] }],
                generationConfig: { responseModalities: ["AUDIO"] },
                model: "gemini-2.5-flash-preview-tts"
             };
             const response = await fetch(apiUrl, {
                 method: 'POST',
                 headers: { 'Content-Type': 'application/json' },
                 body: JSON.stringify(payload)
             });
             if (!response.ok) throw new Error(`API request failed with status ${response.status}`);
             const result = await response.json();
             const audioData = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.data;
             const mimeType = result?.candidates?.[0]?.content?.parts?.[0]?.inlineData?.mimeType;

             if (audioData && mimeType && mimeType.startsWith("audio/")) {
                const sampleRate = parseInt(mimeType.match(/rate=(\d+)/)[1], 10);
                const pcmData = base64ToArrayBuffer(audioData);
                const pcm16 = new Int16Array(pcmData);
                const wavBlob = pcmToWav(pcm16, 1, sampleRate);
                return URL.createObjectURL(wavBlob);
             }
             return null;
        }

        function base64ToArrayBuffer(base64) {
            const binaryString = window.atob(base64);
            const len = binaryString.length;
            const bytes = new Uint8Array(len);
            for (let i = 0; i < len; i++) { bytes[i] = binaryString.charCodeAt(i); }
            return bytes.buffer;
        }

        function pcmToWav(pcmData, numChannels, sampleRate) {
            const buffer = new ArrayBuffer(44 + pcmData.length * 2);
            const view = new DataView(buffer);
            const writeString = (view, offset, string) => {
                for (let i = 0; i < string.length; i++) view.setUint8(offset + i, string.charCodeAt(i));
            };
            writeString(view, 0, 'RIFF');
            view.setUint32(4, 36 + pcmData.length * 2, true);
            writeString(view, 8, 'WAVE');
            writeString(view, 12, 'fmt ');
            view.setUint32(16, 16, true);
            view.setUint16(20, 1, true);
            view.setUint16(22, numChannels, true);
            view.setUint32(24, sampleRate, true);
            view.setUint32(28, sampleRate * numChannels * 2, true);
            view.setUint16(32, numChannels * 2, true);
            view.setUint16(34, 16, true);
            writeString(view, 36, 'data');
            view.setUint32(40, pcmData.length * 2, true);
            for (let i = 0; i < pcmData.length; i++) view.setInt16(44 + i * 2, pcmData[i], true);
            return new Blob([view], { type: 'audio/wav' });
        }
    });
    </script>
</body>
</html>


